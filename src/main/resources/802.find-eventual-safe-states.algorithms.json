{"id":820,"fid":802,"name":"Find Eventual Safe States","slug":"find-eventual-safe-states","link":"https://leetcode.com/problems/find-eventual-safe-states/description/","percent":41.222520955242764,"level":"Medium","category":"algorithms","totalAC":"10.4K","totalSubmit":"25.3K","desc":"In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\r\n\r\nNow, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\r\n\r\nWhich nodes are eventually safe?  Return them as an array in sorted order.\r\n\r\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\r\n\r\n\r\nExample:\r\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\r\nOutput: [2,4,5,6]\r\nHere is a diagram of the above graph.\r\n\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\n\r\n\tgraph will have length at most 10000.\r\n\tThe number of edges in the graph will not exceed 32000.\r\n\tEach graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1].\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        \n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        \n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def eventualSafeNodes(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def eventualSafeNodes(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "},{"value":"c","text":"C","defaultCode":"/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* eventualSafeNodes(int** graph, int graphRowSize, int *graphColSizes, int* returnSize) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public IList<int> EventualSafeNodes(int[][] graph) {\n        \n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number[][]} graph\n * @return {number[]}\n */\nvar eventualSafeNodes = function(graph) {\n    \n};"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer[][]} graph\n# @return {Integer[]}\ndef eventual_safe_nodes(graph)\n    \nend"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func eventualSafeNodes(_ graph: [[Int]]) -> [Int] {\n\n    }\n}"},{"value":"golang","text":"Go","defaultCode":"func eventualSafeNodes(graph [][]int) []int {\n    \n}"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def eventualSafeNodes(graph: Array[Array[Int]]): List[Int] = {\n        \n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun eventualSafeNodes(graph: Array<IntArray>): List<Int> {\n        \n    }\n}"}],"testcase":"[[1,2],[2,3],[5],[0],[5],[],[]]","testable":true,"templateMeta":{"name":"eventualSafeNodes","params":[{"name":"graph","type":"integer[][]"}],"return":{"type":"list<integer>"}}}