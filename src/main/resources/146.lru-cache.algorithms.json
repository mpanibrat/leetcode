{"id":146,"fid":146,"name":"LRU Cache","slug":"lru-cache","link":"https://leetcode.com/problems/lru-cache/description/","percent":22.078281398018156,"level":"Hard","category":"algorithms","totalAC":"220.2K","totalSubmit":"997.5K","desc":"\r\nDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\r\n\r\n\r\n\r\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\r\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\r\n\r\n\r\nFollow up:\r\nCould you do both operations in O(1) time complexity?\r\n\r\nExample:\r\n\r\nLRUCache cache = new LRUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.put(4, 4);    // evicts key 1\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class LRUCache {\r\npublic:\r\n    LRUCache(int capacity) {\r\n        \r\n    }\r\n    \r\n    int get(int key) {\r\n        \r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */"},{"value":"java","text":"Java","defaultCode":"class LRUCache {\r\n\r\n    public LRUCache(int capacity) {\r\n        \r\n    }\r\n    \r\n    public int get(int key) {\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */"},{"value":"python","text":"Python","defaultCode":"class LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        \r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: void\r\n        \"\"\"\r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)"},{"value":"python3","text":"Python3","defaultCode":"class LRUCache:\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        \r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: void\r\n        \"\"\"\r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)"},{"value":"c","text":"C","defaultCode":"typedef struct {\r\n    \r\n} LRUCache;\r\n\r\nLRUCache* lRUCacheCreate(int capacity) {\r\n    \r\n}\r\n\r\nint lRUCacheGet(LRUCache* obj, int key) {\r\n    \r\n}\r\n\r\nvoid lRUCachePut(LRUCache* obj, int key, int value) {\r\n    \r\n}\r\n\r\nvoid lRUCacheFree(LRUCache* obj) {\r\n    \r\n}\r\n\r\n/**\r\n * Your LRUCache struct will be instantiated and called as such:\r\n * struct LRUCache* obj = lRUCacheCreate(capacity);\r\n * int param_1 = lRUCacheGet(obj, key);\r\n * lRUCachePut(obj, key, value);\r\n * lRUCacheFree(obj);\r\n */"},{"value":"csharp","text":"C#","defaultCode":"public class LRUCache {\r\n\r\n    public LRUCache(int capacity) {\r\n        \r\n    }\r\n    \r\n    public int Get(int key) {\r\n        \r\n    }\r\n    \r\n    public void Put(int key, int value) {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.Get(key);\r\n * obj.Put(key,value);\r\n */"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    \r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    \r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    \r\n};\r\n\r\n/** \r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = Object.create(LRUCache).createNew(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */"},{"value":"ruby","text":"Ruby","defaultCode":"class LRUCache\r\n\r\n=begin\r\n    :type capacity: Integer\r\n=end\r\n    def initialize(capacity)\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    :type key: Integer\r\n    :rtype: Integer\r\n=end\r\n    def get(key)\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    :type key: Integer\r\n    :type value: Integer\r\n    :rtype: Void\r\n=end\r\n    def put(key, value)\r\n        \r\n    end\r\n\r\n\r\nend\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache.new(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key, value)"},{"value":"swift","text":"Swift","defaultCode":"\nclass LRUCache {\n\n    init(_ capacity: Int) {\n        \n    }\n    \n    func get(_ key: Int) -> Int {\n      \n    }\n    \n    func put(_ key: Int, _ value: Int) {\n      \n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * let obj = LRUCache(capacity)\n * let ret_1: Int = obj.get(key)\n * obj.put(key, value)\n */\n "},{"value":"golang","text":"Go","defaultCode":"type LRUCache struct {\r\n    \r\n}\r\n\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    \r\n}\r\n\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    \r\n}\r\n\r\n\r\nfunc (this *LRUCache) Put(key int, value int)  {\r\n    \r\n}\r\n\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * obj := Constructor(capacity);\r\n * param_1 := obj.Get(key);\r\n * obj.Put(key,value);\r\n */"},{"value":"scala","text":"Scala","defaultCode":"class LRUCache(_capacity: Int) {\n\n    def get(key: Int): Int = {\n        \n    }\n\n    def put(key: Int, value: Int) {\n        \n    }\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */"},{"value":"kotlin","text":"Kotlin","defaultCode":"class LRUCache(capacity: Int) {\n\n    fun get(key: Int): Int {\n        \n    }\n\n    fun put(key: Int, value: Int) {\n        \n    }\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */"}],"testcase":"[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]","testable":true,"templateMeta":{"classname":"LRUCache","maxbytesperline":200000,"constructor":{"params":[{"type":"integer","name":"capacity"}]},"methods":[{"name":"get","params":[{"type":"integer","name":"key"}],"return":{"type":"integer"}},{"name":"put","params":[{"type":"integer","name":"key"},{"type":"integer","name":"value"}],"return":{"type":"void"}}],"systemdesign":true,"params":[{"name":"inputs","type":"integer[]"},{"name":"inputs","type":"integer[]"}],"return":{"type":"list<String>","dealloc":true}}}