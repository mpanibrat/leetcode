{"id":281,"fid":281,"name":"Zigzag Iterator","slug":"zigzag-iterator","link":"https://leetcode.com/problems/zigzag-iterator/description/","percent":54.38512584444312,"level":"Medium","category":"algorithms","totalAC":"45.5K","totalSubmit":"83.6K","desc":"Given two 1d vectors, implement an iterator to return their elements alternately.\r\n\r\nExample:\r\n\r\n\r\nInput:\r\nv1 = [1,2]\r\nv2 = [3,4,5,6] \r\n\r\nOutput: [1,3,2,4,5,6]\r\n\r\nExplanation: By calling next repeatedly until hasNext returns false, \r\n             the order of elements returned by next should be: [1,3,2,4,5,6].\r\n\r\nFollow up: What if you are given k 1d vectors? How well can your code be extended to such cases?\r\n\r\nClarification for the follow up question:\r\nThe \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\". For example:\r\n\r\n\r\nInput:\r\n[1,2,3]\r\n[4,5,6,7]\r\n[8,9]\r\n\r\nOutput: [1,4,8,2,5,9,3,6,7].\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class ZigzagIterator {\r\npublic:\r\n    ZigzagIterator(vector<int>& v1, vector<int>& v2) {\r\n        \r\n    }\r\n\r\n    int next() {\r\n        \r\n    }\r\n\r\n    bool hasNext() {\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your ZigzagIterator object will be instantiated and called as such:\r\n * ZigzagIterator i(v1, v2);\r\n * while (i.hasNext()) cout << i.next();\r\n */"},{"value":"java","text":"Java","defaultCode":"public class ZigzagIterator {\r\n\r\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\r\n        \r\n    }\r\n\r\n    public int next() {\r\n        \r\n    }\r\n\r\n    public boolean hasNext() {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your ZigzagIterator object will be instantiated and called as such:\r\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\r\n * while (i.hasNext()) v[f()] = i.next();\r\n */"},{"value":"python","text":"Python","defaultCode":"class ZigzagIterator(object):\r\n\r\n    def __init__(self, v1, v2):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        :type v1: List[int]\r\n        :type v2: List[int]\r\n        \"\"\"\r\n        \r\n\r\n    def next(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n\r\n    def hasNext(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        \r\n\r\n# Your ZigzagIterator object will be instantiated and called as such:\r\n# i, v = ZigzagIterator(v1, v2), []\r\n# while i.hasNext(): v.append(i.next())"},{"value":"c","text":"C","defaultCode":"struct ZigzagIterator {\r\n    \r\n};\r\n\r\nstruct ZigzagIterator *zigzagIteratorCreate(int* v1, int v1Size, int* v2, int v2Size) {\r\n    \r\n}\r\n\r\nbool zigzagIteratorHasNext(struct ZigzagIterator *iter) {\r\n    \r\n}\r\n\r\nint zigzagIteratorNext(struct ZigzagIterator *iter) {\r\n    \r\n}\r\n\r\n/** Deallocates memory previously allocated for the iterator */\r\nvoid zigzagIteratorFree(struct ZigzagIterator *iter) {\r\n    \r\n}\r\n\r\n/**\r\n * Your ZigzagIterator will be called like this:\r\n * struct ZigzagIterator *i = zigzagIteratorCreate(v1, v1Size, v2, v2Size);\r\n * while (zigzagIteratorHasNext(i)) printf(\"%d\\n\", zigzagIteratorNext(i));\r\n * zigzagIteratorFree(i);\r\n */"},{"value":"csharp","text":"C#","defaultCode":"public class ZigzagIterator {\r\n\r\n    public ZigzagIterator(IList<int> v1, IList<int> v2) {\r\n        \r\n    }\r\n\r\n    public bool HasNext() {\r\n        \r\n    }\r\n\r\n    public int Next() {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your ZigzagIterator will be called like this:\r\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\r\n * while (i.HasNext()) v[f()] = i.Next();\r\n */"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * @constructor\r\n * @param {Integer[]} v1\r\n * @param {Integer[]} v1\r\n */\r\nvar ZigzagIterator = function ZigzagIterator(v1, v2) {\r\n    \r\n};\r\n\r\n\r\n/**\r\n * @this ZigzagIterator\r\n * @returns {boolean}\r\n */\r\nZigzagIterator.prototype.hasNext = function hasNext() {\r\n    \r\n};\r\n\r\n/**\r\n * @this ZigzagIterator\r\n * @returns {integer}\r\n */\r\nZigzagIterator.prototype.next = function next() {\r\n    \r\n};\r\n\r\n/**\r\n * Your ZigzagIterator will be called like this:\r\n * var i = new ZigzagIterator(v1, v2), a = [];\r\n * while (i.hasNext()) a.push(i.next());\r\n*/"},{"value":"ruby","text":"Ruby","defaultCode":"class ZigzagIterator\r\n    # @param {Integer[]} v1\r\n    # @param {Integer[]} v2\r\n    def initialize(v1, v2)\r\n        \r\n    end\r\n\r\n    # @return {Boolean}\r\n    def has_next\r\n        \r\n    end\r\n\r\n    # @return {Integer}\r\n    def next\r\n        \r\n    end\r\nend\r\n\r\n# Your ZigzagIterator will be called like this:\r\n# i, v = ZigzagIterator.new(v1, v2), []\r\n# while i.has_next()\r\n#    v << i.next\r\n# end"}],"testcase":"[1,2]\n[3,4,5,6]","testable":true,"templateMeta":{"name":"ZigzagIterator","generatedefinition":false,"params":[{"name":"v1","type":"list<integer>"},{"name":"v2","type":"list<integer>"}],"return":{"type":"list<integer>","dealloc":true},"generatedriver":false}}