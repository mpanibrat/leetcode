{"id":173,"fid":173,"name":"Binary Search Tree Iterator","slug":"binary-search-tree-iterator","link":"https://leetcode.com/problems/binary-search-tree-iterator/description/","percent":45.021307076523605,"level":"Medium","category":"algorithms","totalAC":"160.9K","totalSubmit":"357.4K","desc":"Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\r\n\r\nCalling next() will return the next smallest number in the BST.\r\n\r\nNote: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. \r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.","templates":[{"value":"cpp","text":"C++","defaultCode":"/**\r\n * Definition for binary tree\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass BSTIterator {\r\npublic:\r\n    BSTIterator(TreeNode *root) {\r\n        \r\n    }\r\n\r\n    /** @return whether we have a next smallest number */\r\n    bool hasNext() {\r\n        \r\n    }\r\n\r\n    /** @return the next smallest number */\r\n    int next() {\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your BSTIterator will be called like this:\r\n * BSTIterator i = BSTIterator(root);\r\n * while (i.hasNext()) cout << i.next();\r\n */"},{"value":"java","text":"Java","defaultCode":"/**\r\n * Definition for binary tree\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\n\r\npublic class BSTIterator {\r\n\r\n    public BSTIterator(TreeNode root) {\r\n        \r\n    }\r\n\r\n    /** @return whether we have a next smallest number */\r\n    public boolean hasNext() {\r\n        \r\n    }\r\n\r\n    /** @return the next smallest number */\r\n    public int next() {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your BSTIterator will be called like this:\r\n * BSTIterator i = new BSTIterator(root);\r\n * while (i.hasNext()) v[f()] = i.next();\r\n */"},{"value":"python","text":"Python","defaultCode":"# Definition for a  binary tree node\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass BSTIterator(object):\r\n    def __init__(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        \"\"\"\r\n        \r\n\r\n    def hasNext(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        \r\n\r\n    def next(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n\r\n# Your BSTIterator will be called like this:\r\n# i, v = BSTIterator(root), []\r\n# while i.hasNext(): v.append(i.next())"},{"value":"c","text":"C","defaultCode":"/**\r\n * Definition for binary tree\r\n * struct TreeNode {\r\n *     int val;\r\n *     struct TreeNode *left;\r\n *     struct TreeNode *right;\r\n * };\r\n */\r\nstruct BSTIterator {\r\n    \r\n};\r\n\r\nstruct BSTIterator *bstIteratorCreate(struct TreeNode *root) {\r\n    \r\n}\r\n\r\n/** @return whether we have a next smallest number */\r\nbool bstIteratorHasNext(struct BSTIterator *iter) {\r\n    \r\n}\r\n\r\n/** @return the next smallest number */\r\nint bstIteratorNext(struct BSTIterator *iter) {\r\n    \r\n}\r\n\r\n/** Deallocates memory previously allocated for the iterator */\r\nvoid bstIteratorFree(struct BSTIterator *iter) {\r\n    \r\n}\r\n\r\n/**\r\n * Your BSTIterator will be called like this:\r\n * struct BSTIterator *i = bstIteratorCreate(root);\r\n * while (bstIteratorHasNext(i)) printf(\"%d\\n\", bstIteratorNext(i));\r\n * bstIteratorFree(i);\r\n */"},{"value":"csharp","text":"C#","defaultCode":"/**\r\n * Definition for binary tree\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left;\r\n *     public TreeNode right;\r\n *     public TreeNode(int x) { val = x; }\r\n * }\r\n */\r\n\r\npublic class BSTIterator {\r\n\r\n    public BSTIterator(TreeNode root) {\r\n        \r\n    }\r\n\r\n    /** @return whether we have a next smallest number */\r\n    public bool HasNext() {\r\n        \r\n    }\r\n\r\n    /** @return the next smallest number */\r\n    public int Next() {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your BSTIterator will be called like this:\r\n * BSTIterator i = new BSTIterator(root);\r\n * while (i.HasNext()) v[f()] = i.Next();\r\n */"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * Definition for binary tree\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @constructor\r\n * @param {TreeNode} root - root of the binary search tree\r\n */\r\nvar BSTIterator = function(root) {\r\n    \r\n};\r\n\r\n\r\n/**\r\n * @this BSTIterator\r\n * @returns {boolean} - whether we have a next smallest number\r\n */\r\nBSTIterator.prototype.hasNext = function() {\r\n    \r\n};\r\n\r\n/**\r\n * @this BSTIterator\r\n * @returns {number} - the next smallest number\r\n */\r\nBSTIterator.prototype.next = function() {\r\n    \r\n};\r\n\r\n/**\r\n * Your BSTIterator will be called like this:\r\n * var i = new BSTIterator(root), a = [];\r\n * while (i.hasNext()) a.push(i.next());\r\n*/"},{"value":"ruby","text":"Ruby","defaultCode":"# Definition for a binary tree node.\r\n# class TreeNode\r\n#     attr_accessor :val, :left, :right\r\n#     def initialize(val)\r\n#         @val = val\r\n#         @left, @right = nil, nil\r\n#     end\r\n# end\r\n\r\nclass BSTIterator\r\n    # @param {TreeNode} root\r\n    def initialize(root)\r\n        \r\n    end\r\n\r\n    # @return {Boolean}\r\n    def has_next\r\n        \r\n    end\r\n\r\n    # @return {Integer}\r\n    def next\r\n        \r\n    end\r\nend\r\n\r\n# Your BSTIterator will be called like this:\r\n# i, v = BSTIterator.new(root), []\r\n# while i.has_next()\r\n#    v << i.next\r\n# end"}],"testcase":"[]","testable":true,"templateMeta":{"name":"BSTIterator","generatedefinition":false,"params":[{"name":"root","type":"TreeNode"}],"return":{"type":"list<integer>","dealloc":true},"generatedriver":false}}