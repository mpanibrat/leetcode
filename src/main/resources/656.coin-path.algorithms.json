{"id":656,"fid":656,"name":"Coin Path","slug":"coin-path","link":"https://leetcode.com/problems/coin-path/description/","percent":25.95493710546929,"level":"Hard","category":"algorithms","totalAC":"5.6K","totalSubmit":"21.7K","desc":"\r\nGiven an array A (index starts at 1) consisting of N integers: A1, A2, ..., AN and an integer B. The integer B denotes that from any place (suppose the index is i) in the array A, you can jump to any one of the place in the array A indexed i+1, i+2, …, i+B if this place can be jumped to. Also, if you step on the index i, you have to pay Ai coins. If Ai is -1, it means you can’t jump to the place indexed i in the array.\r\n\r\n\r\n\r\nNow, you start from the place indexed 1 in the array A, and your aim is to reach the place indexed N using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed N using minimum coins.\r\n\r\n\r\n\r\nIf there are multiple paths with the same cost, return the lexicographically smallest such path.\r\n\r\n\r\nIf it's not possible to reach the place indexed N then you need to return an empty array.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,2,4,-1,2], 2\r\nOutput: [1,3,5]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,4,-1,2], 1\r\nOutput: []\r\n\r\n\r\n\r\nNote:\r\n\r\nPath Pa1, Pa2, ..., Pan is lexicographically smaller than Pb1, Pb2, ..., Pbm, if and only if at the first i where Pai and Pbi differ, Pai < Pbi; when no such i exists, then n < m.\r\nA1 >= 0. A2, ..., AN (if exist) will in the range of [-1, 100]. \r\nLength of A is in the range of [1, 1000].\r\nB is in the range of [1, 100].\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\r\npublic:\r\n    vector<int> cheapestJump(vector<int>& A, int B) {\r\n        \r\n    }\r\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public List<Integer> cheapestJump(int[] A, int B) {\n        \n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\r\n    def cheapestJump(self, A, B):\r\n        \"\"\"\r\n        :type A: List[int]\r\n        :type B: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        "},{"value":"python3","text":"Python3","defaultCode":"class Solution:\r\n    def cheapestJump(self, A, B):\r\n        \"\"\"\r\n        :type A: List[int]\r\n        :type B: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        "},{"value":"c","text":"C","defaultCode":"/**\r\n * Return an array of size *returnSize.\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* cheapestJump(int* A, int ASize, int B, int* returnSize) {\r\n    \r\n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\r\n    public IList<int> CheapestJump(int[] A, int B) {\r\n        \r\n    }\r\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * @param {number[]} A\r\n * @param {number} B\r\n * @return {number[]}\r\n */\r\nvar cheapestJump = function(A, B) {\r\n    \r\n};"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer[]} a\r\n# @param {Integer} b\r\n# @return {Integer[]}\r\ndef cheapest_jump(a, b)\r\n    \r\nend"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func cheapestJump(_ A: [Int], _ B: Int) -> [Int] {\n\n    }\n}"},{"value":"golang","text":"Go","defaultCode":"func cheapestJump(A []int, B int) []int {\r\n    \r\n}"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def cheapestJump(A: Array[Int], B: Int): List[Int] = {\n        \n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun cheapestJump(A: IntArray, B: Int): List<Int> {\n        \n    }\n}"}],"testcase":"[1,2,4,-1,2]\n2","testable":true,"templateMeta":{"name":"cheapestJump","params":[{"name":"A","type":"integer[]"},{"name":"B","type":"integer"}],"return":{"type":"list<integer>"}}}