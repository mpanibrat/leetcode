{"id":364,"fid":364,"name":"Nested List Weight Sum II","slug":"nested-list-weight-sum-ii","link":"https://leetcode.com/problems/nested-list-weight-sum-ii/description/","percent":55.29174514392253,"level":"Medium","category":"algorithms","totalAC":"29.1K","totalSubmit":"52.6K","desc":"Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nDifferent from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.\r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: [[1,1],2,[1,1]]\r\nOutput: 8 \r\nExplanation: Four 1's at depth 1, one 2 at depth 2.\r\n\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [1,[4,[6]]]\r\nOutput: 17 \r\nExplanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.\r\n\r\n\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *   public:\r\n *     // Constructor initializes an empty nested list.\r\n *     NestedInteger();\r\n *\r\n *     // Constructor initializes a single integer.\r\n *     NestedInteger(int value);\r\n *\r\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     bool isInteger() const;\r\n *\r\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // The result is undefined if this NestedInteger holds a nested list\r\n *     int getInteger() const;\r\n *\r\n *     // Set this NestedInteger to hold a single integer.\r\n *     void setInteger(int value);\r\n *\r\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\r\n *     void add(const NestedInteger &ni);\r\n *\r\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // The result is undefined if this NestedInteger holds a single integer\r\n *     const vector<NestedInteger> &getList() const;\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int depthSumInverse(vector<NestedInteger>& nestedList) {\r\n        \r\n    }\r\n};"},{"value":"java","text":"Java","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * public interface NestedInteger {\r\n *     // Constructor initializes an empty nested list.\r\n *     public NestedInteger();\r\n *\r\n *     // Constructor initializes a single integer.\r\n *     public NestedInteger(int value);\r\n *\r\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     public boolean isInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     public Integer getInteger();\r\n *\r\n *     // Set this NestedInteger to hold a single integer.\r\n *     public void setInteger(int value);\r\n *\r\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\r\n *     public void add(NestedInteger ni);\r\n *\r\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     public List<NestedInteger> getList();\r\n * }\r\n */\r\nclass Solution {\r\n    public int depthSumInverse(List<NestedInteger> nestedList) {\r\n        \r\n    }\r\n}"},{"value":"python","text":"Python","defaultCode":"# \"\"\"\r\n# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n# \"\"\"\r\n#class NestedInteger(object):\r\n#    def __init__(self, value=None):\r\n#        \"\"\"\r\n#        If value is not specified, initializes an empty list.\r\n#        Otherwise initializes a single integer equal to value.\r\n#        \"\"\"\r\n#\r\n#    def isInteger(self):\r\n#        \"\"\"\r\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\r\n#        :rtype bool\r\n#        \"\"\"\r\n#\r\n#    def add(self, elem):\r\n#        \"\"\"\r\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\r\n#        :rtype void\r\n#        \"\"\"\r\n#\r\n#    def setInteger(self, value):\r\n#        \"\"\"\r\n#        Set this NestedInteger to hold a single integer equal to value.\r\n#        :rtype void\r\n#        \"\"\"\r\n#\r\n#    def getInteger(self):\r\n#        \"\"\"\r\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\r\n#        Return None if this NestedInteger holds a nested list\r\n#        :rtype int\r\n#        \"\"\"\r\n#\r\n#    def getList(self):\r\n#        \"\"\"\r\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\r\n#        Return None if this NestedInteger holds a single integer\r\n#        :rtype List[NestedInteger]\r\n#        \"\"\"\r\n\r\nclass Solution(object):\r\n    def depthSumInverse(self, nestedList):\r\n        \"\"\"\r\n        :type nestedList: List[NestedInteger]\r\n        :rtype: int\r\n        \"\"\"\r\n        "},{"value":"python3","text":"Python3","defaultCode":"# \"\"\"\r\n# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n# \"\"\"\r\n#class NestedInteger:\r\n#    def __init__(self, value=None):\r\n#        \"\"\"\r\n#        If value is not specified, initializes an empty list.\r\n#        Otherwise initializes a single integer equal to value.\r\n#        \"\"\"\r\n#\r\n#    def isInteger(self):\r\n#        \"\"\"\r\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\r\n#        :rtype bool\r\n#        \"\"\"\r\n#\r\n#    def add(self, elem):\r\n#        \"\"\"\r\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\r\n#        :rtype void\r\n#        \"\"\"\r\n#\r\n#    def setInteger(self, value):\r\n#        \"\"\"\r\n#        Set this NestedInteger to hold a single integer equal to value.\r\n#        :rtype void\r\n#        \"\"\"\r\n#\r\n#    def getInteger(self):\r\n#        \"\"\"\r\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\r\n#        Return None if this NestedInteger holds a nested list\r\n#        :rtype int\r\n#        \"\"\"\r\n#\r\n#    def getList(self):\r\n#        \"\"\"\r\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\r\n#        Return None if this NestedInteger holds a single integer\r\n#        :rtype List[NestedInteger]\r\n#        \"\"\"\r\n\r\nclass Solution:\r\n    def depthSumInverse(self, nestedList):\r\n        \"\"\"\r\n        :type nestedList: List[NestedInteger]\r\n        :rtype: int\r\n        \"\"\"\r\n        "},{"value":"c","text":"C","defaultCode":"/**\r\n * *********************************************************************\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * *********************************************************************\r\n *\r\n * // Initializes an empty nested list and return a reference to the nested integer.\r\n * struct NestedInteger *NestedIntegerInit();\r\n *\r\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n * bool NestedIntegerIsInteger(struct NestedInteger *);\r\n *\r\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n * // The result is undefined if this NestedInteger holds a nested list\r\n * int NestedIntegerGetInteger(struct NestedInteger *);\r\n *\r\n * // Set this NestedInteger to hold a single integer.\r\n * void NestedIntegerSetInteger(struct NestedInteger *ni, int value);\r\n *\r\n * // Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\r\n * void NestedIntegerAdd(struct NestedInteger *ni, struct NestedInteger *elem);\r\n *\r\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n * // The result is undefined if this NestedInteger holds a single integer\r\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\r\n *\r\n * // Return the nested list's size that this NestedInteger holds, if it holds a nested list\r\n * // The result is undefined if this NestedInteger holds a single integer\r\n * int NestedIntegerGetListSize(struct NestedInteger *);\r\n * };\r\n */\r\nint depthSumInverse(struct NestedInteger** nestedList, int nestedListSize) {\r\n    \r\n}"},{"value":"csharp","text":"C#","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * interface NestedInteger {\r\n *\r\n *     // Constructor initializes an empty nested list.\r\n *     public NestedInteger();\r\n *\r\n *     // Constructor initializes a single integer.\r\n *     public NestedInteger(int value);\r\n *\r\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     bool IsInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     int GetInteger();\r\n *\r\n *     // Set this NestedInteger to hold a single integer.\r\n *     public void SetInteger(int value);\r\n *\r\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\r\n *     public void Add(NestedInteger ni);\r\n *\r\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     IList<NestedInteger> GetList();\r\n * }\r\n */\r\npublic class Solution {\r\n    public int DepthSumInverse(IList<NestedInteger> nestedList) {\r\n        \r\n    }\r\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * function NestedInteger() {\r\n *\r\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     @return {boolean}\r\n *     this.isInteger = function() {\r\n *         ...\r\n *     };\r\n *\r\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     Return null if this NestedInteger holds a nested list\r\n *     @return {integer}\r\n *     this.getInteger = function() {\r\n *         ...\r\n *     };\r\n *\r\n *     Set this NestedInteger to hold a single integer equal to value.\r\n *     @return {void}\r\n *     this.setInteger = function(value) {\r\n *         ...\r\n *     };\r\n *\r\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\r\n *     @return {void}\r\n *     this.add = function(elem) {\r\n *         ...\r\n *     };\r\n *\r\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     Return null if this NestedInteger holds a single integer\r\n *     @return {NestedInteger[]}\r\n *     this.getList = function() {\r\n *         ...\r\n *     };\r\n * };\r\n */\r\n/**\r\n * @param {NestedInteger[]} nestedList\r\n * @return {number}\r\n */\r\nvar depthSumInverse = function(nestedList) {\r\n    \r\n};"},{"value":"ruby","text":"Ruby","defaultCode":"# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n#\r\n#class NestedInteger\r\n#    def is_integer()\r\n#        \"\"\"\r\n#        Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n#        @return {Boolean}\r\n#        \"\"\"\r\n#\r\n#    def get_integer()\r\n#        \"\"\"\r\n#        Return the single integer that this NestedInteger holds, if it holds a single integer\r\n#        Return nil if this NestedInteger holds a nested list\r\n#        @return {Integer}\r\n#        \"\"\"\r\n#\r\n#    def set_integer(value)\r\n#        \"\"\"\r\n#        Set this NestedInteger to hold a single integer equal to value.\r\n#        @return {Void}\r\n#        \"\"\"\r\n#\r\n#    def add(elem)\r\n#        \"\"\"\r\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\r\n#        @return {Void}\r\n#        \"\"\"\r\n#\r\n#    def get_list()\r\n#        \"\"\"\r\n#        Return the nested list that this NestedInteger holds, if it holds a nested list\r\n#        Return nil if this NestedInteger holds a single integer\r\n#        @return {NestedInteger[]}\r\n#        \"\"\"\r\n\r\n# @param {NestedInteger[]} nested_list\r\n# @return {Integer}\r\ndef depth_sum_inverse(nested_list)\r\n    \r\nend"},{"value":"swift","text":"Swift","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public func isInteger() -> Bool\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     public func getInteger() -> Int\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public func setInteger(value: Int)\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public func add(elem: NestedInteger)\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     public func getList() -> [NestedInteger]\n * }\n */\nclass Solution {\n    func depthSumInverse(_ nestedList: [NestedInteger]) -> Int {\n\n    }\n}"},{"value":"golang","text":"Go","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * type NestedInteger struct {\r\n * }\r\n *\r\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n * func (n NestedInteger) IsInteger() bool {}\r\n *\r\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n * // The result is undefined if this NestedInteger holds a nested list\r\n * // So before calling this method, you should have a check\r\n * func (n NestedInteger) GetInteger() int {}\r\n *\r\n * // Set this NestedInteger to hold a single integer.\r\n * func (n *NestedInteger) SetInteger(value int) {}\r\n *\r\n * // Set this NestedInteger to hold a nested list and adds a nested integer to it.\r\n * func (n *NestedInteger) Add(elem NestedInteger) {}\r\n *\r\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n * // The list length is zero if this NestedInteger holds a single integer\r\n * // You can access NestedInteger's List element directly if you want to modify it\r\n * func (n NestedInteger) GetList() []*NestedInteger {}\r\n */\r\nfunc depthSumInverse(nestedList []*NestedInteger) int {\r\n    \r\n}"},{"value":"scala","text":"Scala","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *\r\n *   // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *   def isInteger: Boolean = {}\r\n *\r\n *   // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n *   def getInteger: Int = {}\r\n *\r\n *   // Set this NestedInteger to hold a single integer.\r\n *   def setInteger(i: Int) = {}\r\n *\r\n *   // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n *   def getList = {}\r\n *\r\n *   // Set this NestedInteger to hold a nested list and adds a nested integer to it.\r\n *   def add(ni: NestedInteger) = {}\r\n * }\r\n */\r\nobject Solution {\r\n    def depthSumInverse(nestedList: List[NestedInteger]): Int = {\r\n        \r\n    }\r\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *     // Constructor initializes an empty nested list.\r\n *     constructor()\r\n *\r\n *     // Constructor initializes a single integer.\r\n *     constructor(value: Int)\r\n *\r\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     fun isInteger(): Boolean\r\n *\r\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     fun getInteger(): Int?\r\n *\r\n *     // Set this NestedInteger to hold a single integer.\r\n *     fun setInteger(value: Int): Unit\r\n *\r\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\r\n *     fun add(ni: NestedInteger): Unit\r\n *\r\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     fun getList(): List<NestedInteger>?\r\n * }\r\n */\r\nclass Solution {\r\n    fun depthSumInverse(nestedList: List<NestedInteger>): Int {\r\n        \r\n    }\r\n}"}],"testcase":"[[1,1],2,[1,1]]","testable":true,"templateMeta":{"name":"depthSumInverse","params":[{"name":"nestedList","type":"list<NestedInteger>"}],"return":{"type":"integer"}}}