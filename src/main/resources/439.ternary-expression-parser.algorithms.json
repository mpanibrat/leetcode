{"id":439,"fid":439,"name":"Ternary Expression Parser","slug":"ternary-expression-parser","link":"https://leetcode.com/problems/ternary-expression-parser/description/","percent":52.19230928775874,"level":"Medium","category":"algorithms","totalAC":"12.6K","totalSubmit":"24.1K","desc":"Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).\r\n\r\nNote:\r\n\r\nThe length of the given string is â‰¤ 10000.\r\nEach number will contain only one digit.\r\nThe conditional expressions group right-to-left (as usual in most languages).\r\nThe condition will always be either T or F. That is, the condition will never be a digit.\r\nThe result of the expression will always evaluate to either a digit 0-9, T or F.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"T?2:3\"\r\n\r\nOutput: \"2\"\r\n\r\nExplanation: If true, then result is 2; otherwise result is 3.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"F?1:T?4:5\"\r\n\r\nOutput: \"4\"\r\n\r\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\r\n\r\n             \"(F ? 1 : (T ? 4 : 5))\"                   \"(F ? 1 : (T ? 4 : 5))\"\r\n          -> \"(F ? 1 : 4)\"                 or       -> \"(T ? 4 : 5)\"\r\n          -> \"4\"                                    -> \"4\"\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"T?T?F:5:3\"\r\n\r\nOutput: \"F\"\r\n\r\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\r\n\r\n             \"(T ? (T ? F : 5) : 3)\"                   \"(T ? (T ? F : 5) : 3)\"\r\n          -> \"(T ? F : 3)\"                 or       -> \"(T ? F : 5)\"\r\n          -> \"F\"                                    -> \"F\"\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\r\npublic:\r\n    string parseTernary(string expression) {\r\n        \r\n    }\r\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public String parseTernary(String expression) {\n        \n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\r\n    def parseTernary(self, expression):\r\n        \"\"\"\r\n        :type expression: str\r\n        :rtype: str\r\n        \"\"\"\r\n        "},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def parseTernary(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: str\n        \"\"\"\n        "},{"value":"c","text":"C","defaultCode":"char* parseTernary(char* expression) {\r\n    \r\n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\r\n    public string ParseTernary(string expression) {\r\n        \r\n    }\r\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * @param {string} expression\r\n * @return {string}\r\n */\r\nvar parseTernary = function(expression) {\r\n    \r\n};"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {String} expression\r\n# @return {String}\r\ndef parse_ternary(expression)\r\n    \r\nend"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func parseTernary(_ expression: String) -> String {\n\n    }\n}"},{"value":"golang","text":"Go","defaultCode":"func parseTernary(expression string) string {\r\n    \r\n}"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def parseTernary(expression: String): String = {\n        \n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun parseTernary(expression: String): String {\n        \n    }\n}"}],"testcase":"\"T?2:3\"","testable":true,"templateMeta":{"name":"parseTernary","params":[{"name":"expression","type":"string"}],"return":{"type":"string"}}}