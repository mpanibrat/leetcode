{"id":341,"fid":341,"name":"Flatten Nested List Iterator","slug":"flatten-nested-list-iterator","link":"https://leetcode.com/problems/flatten-nested-list-iterator/description/","percent":45.07205476806198,"level":"Medium","category":"algorithms","totalAC":"84K","totalSubmit":"186.4K","desc":"Given a nested list of integers, implement an iterator to flatten it.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: [[1,1],2,[1,1]]\r\nOutput: [1,1,2,1,1]\r\nExplanation: By calling next repeatedly until hasNext returns false, \r\n             the order of elements returned by next should be: [1,1,2,1,1].\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [1,[4,[6]]]\r\nOutput: [1,4,6]\r\nExplanation: By calling next repeatedly until hasNext returns false, \r\n             the order of elements returned by next should be: [1,4,6].\r\n\r\n\r\n\r\n","templates":[{"value":"cpp","text":"C++","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *   public:\r\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     bool isInteger() const;\r\n *\r\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // The result is undefined if this NestedInteger holds a nested list\r\n *     int getInteger() const;\r\n *\r\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // The result is undefined if this NestedInteger holds a single integer\r\n *     const vector<NestedInteger> &getList() const;\r\n * };\r\n */\r\nclass NestedIterator {\r\npublic:\r\n    NestedIterator(vector<NestedInteger> &nestedList) {\r\n        \r\n    }\r\n\r\n    int next() {\r\n        \r\n    }\r\n\r\n    bool hasNext() {\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your NestedIterator object will be instantiated and called as such:\r\n * NestedIterator i(nestedList);\r\n * while (i.hasNext()) cout << i.next();\r\n */"},{"value":"java","text":"Java","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * public interface NestedInteger {\r\n *\r\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     public boolean isInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     public Integer getInteger();\r\n *\r\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     public List<NestedInteger> getList();\r\n * }\r\n */\r\npublic class NestedIterator implements Iterator<Integer> {\r\n\r\n    public NestedIterator(List<NestedInteger> nestedList) {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public Integer next() {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public boolean hasNext() {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your NestedIterator object will be instantiated and called as such:\r\n * NestedIterator i = new NestedIterator(nestedList);\r\n * while (i.hasNext()) v[f()] = i.next();\r\n */"},{"value":"python","text":"Python","defaultCode":"# \"\"\"\r\n# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n# \"\"\"\r\n#class NestedInteger(object):\r\n#    def isInteger(self):\r\n#        \"\"\"\r\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\r\n#        :rtype bool\r\n#        \"\"\"\r\n#\r\n#    def getInteger(self):\r\n#        \"\"\"\r\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\r\n#        Return None if this NestedInteger holds a nested list\r\n#        :rtype int\r\n#        \"\"\"\r\n#\r\n#    def getList(self):\r\n#        \"\"\"\r\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\r\n#        Return None if this NestedInteger holds a single integer\r\n#        :rtype List[NestedInteger]\r\n#        \"\"\"\r\n\r\nclass NestedIterator(object):\r\n\r\n    def __init__(self, nestedList):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        :type nestedList: List[NestedInteger]\r\n        \"\"\"\r\n        \r\n\r\n    def next(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n\r\n    def hasNext(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        \r\n\r\n# Your NestedIterator object will be instantiated and called as such:\r\n# i, v = NestedIterator(nestedList), []\r\n# while i.hasNext(): v.append(i.next())"},{"value":"c","text":"C","defaultCode":"/**\r\n * *********************************************************************\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * *********************************************************************\r\n *\r\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n * bool NestedIntegerIsInteger(struct NestedInteger *);\r\n *\r\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n * // The result is undefined if this NestedInteger holds a nested list\r\n * int NestedIntegerGetInteger(struct NestedInteger *);\r\n *\r\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n * // The result is undefined if this NestedInteger holds a single integer\r\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\r\n *\r\n * // Return the nested list's size that this NestedInteger holds, if it holds a nested list\r\n * // The result is undefined if this NestedInteger holds a single integer\r\n * int NestedIntegerGetListSize(struct NestedInteger *);\r\n * };\r\n */\r\nstruct NestedIterator {\r\n    \r\n};\r\n\r\nstruct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\r\n    \r\n}\r\n\r\nbool nestedIterHasNext(struct NestedIterator *iter) {\r\n    \r\n}\r\n\r\nint nestedIterNext(struct NestedIterator *iter) {\r\n    \r\n}\r\n\r\n/** Deallocates memory previously allocated for the iterator */\r\nvoid nestedIterFree(struct NestedIterator *iter) {\r\n    \r\n}\r\n\r\n/**\r\n * Your NestedIterator will be called like this:\r\n * struct NestedIterator *i = nestedIterCreate(nestedList, nestedListSize);\r\n * while (nestedIterHasNext(i)) printf(\"%d\\n\", nestedIterNext(i));\r\n * nestedIterFree(i);\r\n */"},{"value":"csharp","text":"C#","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * interface NestedInteger {\r\n *\r\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     bool IsInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     int GetInteger();\r\n *\r\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     IList<NestedInteger> GetList();\r\n * }\r\n */\r\npublic class NestedIterator {\r\n\r\n    public NestedIterator(IList<NestedInteger> nestedList) {\r\n        \r\n    }\r\n\r\n    public bool HasNext() {\r\n        \r\n    }\r\n\r\n    public int Next() {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your NestedIterator will be called like this:\r\n * NestedIterator i = new NestedIterator(nestedList);\r\n * while (i.HasNext()) v[f()] = i.Next();\r\n */"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * function NestedInteger() {\r\n *\r\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     @return {boolean}\r\n *     this.isInteger = function() {\r\n *         ...\r\n *     };\r\n *\r\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     Return null if this NestedInteger holds a nested list\r\n *     @return {integer}\r\n *     this.getInteger = function() {\r\n *         ...\r\n *     };\r\n *\r\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     Return null if this NestedInteger holds a single integer\r\n *     @return {NestedInteger[]}\r\n *     this.getList = function() {\r\n *         ...\r\n *     };\r\n * };\r\n */\r\n/**\r\n * @constructor\r\n * @param {NestedInteger[]} nestedList\r\n */\r\nvar NestedIterator = function(nestedList) {\r\n    \r\n};\r\n\r\n\r\n/**\r\n * @this NestedIterator\r\n * @returns {boolean}\r\n */\r\nNestedIterator.prototype.hasNext = function() {\r\n    \r\n};\r\n\r\n/**\r\n * @this NestedIterator\r\n * @returns {integer}\r\n */\r\nNestedIterator.prototype.next = function() {\r\n    \r\n};\r\n\r\n/**\r\n * Your NestedIterator will be called like this:\r\n * var i = new NestedIterator(nestedList), a = [];\r\n * while (i.hasNext()) a.push(i.next());\r\n*/"},{"value":"ruby","text":"Ruby","defaultCode":"# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n#\r\n#class NestedInteger\r\n#    def is_integer()\r\n#        \"\"\"\r\n#        Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n#        @return {Boolean}\r\n#        \"\"\"\r\n#\r\n#    def get_integer()\r\n#        \"\"\"\r\n#        Return the single integer that this NestedInteger holds, if it holds a single integer\r\n#        Return nil if this NestedInteger holds a nested list\r\n#        @return {Integer}\r\n#        \"\"\"\r\n#\r\n#    def get_list()\r\n#        \"\"\"\r\n#        Return the nested list that this NestedInteger holds, if it holds a nested list\r\n#        Return nil if this NestedInteger holds a single integer\r\n#        @return {NestedInteger[]}\r\n#        \"\"\"\r\n\r\nclass NestedIterator\r\n    # @param {NestedInteger[]} nested_list\r\n    def initialize(nested_list)\r\n        \r\n    end\r\n\r\n    # @return {Boolean}\r\n    def has_next\r\n        \r\n    end\r\n\r\n    # @return {Integer}\r\n    def next\r\n        \r\n    end\r\nend\r\n\r\n# Your NestedIterator will be called like this:\r\n# i, v = NestedIterator.new(nested_list), []\r\n# while i.has_next()\r\n#    v << i.next\r\n# end"},{"value":"swift","text":"Swift","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public func isInteger() -> Bool\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     public func getInteger() -> Int\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public func setInteger(value: Int)\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public func add(elem: NestedInteger)\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     public func getList() -> [NestedInteger]\n * }\n */\nclass Solution {\n    func (_ nestedList: [NestedInteger]) -> Int {\n\n    }\n}"}],"testcase":"[[1,1],2,[1,1]]","testable":true,"templateMeta":{"name":"","params":[{"name":"nestedList","type":"list<NestedInteger>"}],"return":{"type":"integer"},"generatedriver":false,"generatedefinition":false}}